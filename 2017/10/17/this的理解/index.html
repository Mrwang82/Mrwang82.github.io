<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>this的理解 | 小小王</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。1.作为纯粹的函数调用this指向全局对象 ####1234567&amp;lt;script&amp;gt;    function aleat() &amp;#123;        // body...        console.log(this);    &amp;#125;    aleat(); //Window &amp;#123;fr">
<meta property="og:type" content="article">
<meta property="og:title" content="this的理解">
<meta property="og:url" content="https://Mrwang82.github.io/2017/10/17/this的理解/index.html">
<meta property="og:site_name" content="小小王">
<meta property="og:description" content="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。1.作为纯粹的函数调用this指向全局对象 ####1234567&amp;lt;script&amp;gt;    function aleat() &amp;#123;        // body...        console.log(this);    &amp;#125;    aleat(); //Window &amp;#123;fr">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-10-17T03:55:08.074Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="this的理解">
<meta name="twitter:description" content="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。1.作为纯粹的函数调用this指向全局对象 ####1234567&amp;lt;script&amp;gt;    function aleat() &amp;#123;        // body...        console.log(this);    &amp;#125;    aleat(); //Window &amp;#123;fr">
  
    <link rel="alternate" href="/atom.xml" title="小小王" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="Mrwang82.github.io/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="Mrwang82.github.io/" id="logo">小小王</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="Mrwang82.github.io/" id="subtitle">小小王的</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="Mrwang82.github.io/">Home</a>
        
          <a class="main-nav-link" href="Mrwang82.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Mrwang82.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-this的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="Mrwang82.github.io/2017/10/17/this的理解/" class="article-date">
  <time datetime="2017-10-17T01:22:20.013Z" itemprop="datePublished">2017-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      this的理解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。"><a href="#this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。" class="headerlink" title="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。"></a>this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</h2><p>1.作为纯粹的函数调用this指向全局对象 ####<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function aleat() &#123;</div><div class="line">        // body...</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">    aleat(); //Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125;</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>2.作为对象的方法调用this指向调用对象 ####<br>3.作为构造函数被调用this指向新的对象（new会改变this的指向） ####<br>4.apply调用this指向apply方法的第一个参数 ####</p>
<h2 id="JS有哪些内置对象-。"><a href="#JS有哪些内置对象-。" class="headerlink" title="JS有哪些内置对象 #。"></a>JS有哪些内置对象 #。</h2><p>Object是JavaScript中所有对象的父对象 ####<br>其他对象：Function、Argument、Math、Date、RegExp、Error ####<br>数据封装类对象：Object、Array、Boolean、Number、String####<br>复杂(引用)类型：对象、数组、函数 ####</p>
<h2 id="表单验证传输的什么数据？明文还是暗文-加密？如何加密？是每一次传输数据，都是加密之后才传输吗？"><a href="#表单验证传输的什么数据？明文还是暗文-加密？如何加密？是每一次传输数据，都是加密之后才传输吗？" class="headerlink" title="表单验证传输的什么数据？明文还是暗文==加密？如何加密？是每一次传输数据，都是加密之后才传输吗？"></a>表单验证传输的什么数据？明文还是暗文==加密？如何加密？是每一次传输数据，都是加密之后才传输吗？</h2><p>GET是从服务器上请求数据，POST是发送数据到服务器。<br>GET方法是把数据参数队列（querystring）加到一个URL上，值和表单是一一对应的。比如说，name=John。在队列里，值和表单用一个&amp;符号分开，空格用+号替换，特殊的符号转换成十六进制的代码。<br>因为这一队列在URL里边，这样队列的参数就能看得到，可以被记录下来，或更改。通常GET方法还限制字符的大小（大概是256字节）。<br>事实上POST方法可以没有时间限制的传递数据到服务器，用户在浏览器端是看不到这一过程的，所以POST方法比较适合用于发送一个保密的（比如信用卡号）或者比较大量的数据到服务器。</p>
<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>Post是允许传输大量数据的方法，而Get方法会将所要传输的数据附在网址后面，然后一起送达服务器，因此传送的数据量就会受到限制，但是执行效率却比Post方法好。<br>get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；<br>所以，表达如果是向服务器传输数据(如帐号密码等)都是加密数据(post)，如果只是单单想要从服务器获得数据或者传输的数据并不重要，可以直接使用明文方式传输(get)</p>
<h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><p>对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题<br>1.下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header&#123;&quot;Access-Control-Allow-Origin: * &quot;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p> 在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的<br>SONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function dosomething(jsondata)&#123;</div><div class="line">//处理获得的JSON数据</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>首先第一个script标签定义了一个处理数据的函数；然后第二个script标签载入一个js文件，http：//example.com/data.php是数据所在地址，但是因为是当做js来引入的，所以http：//example.com/data.php返回的必须是一个能执行的js文件；<br>最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php $callback = $_GET[&apos;callback&apos;]; //得到回调函数名</div><div class="line">$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //要返回的数据</div><div class="line">echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;; //输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理"></a>jsonp的原理</h2><p>jsonp的原理：动态创建script标签，回调函数### JSONP(JSONwithPadding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料而这种使用模式就是所谓的JSONP用JSONP抓到的资料并不是JSON而是任意的JavaScript用JavaScript直译器执行而不是用JSON解析器解析。</p>
<h2 id="jsonp为什么不是ajax"><a href="#jsonp为什么不是ajax" class="headerlink" title="jsonp为什么不是ajax"></a>jsonp为什么不是ajax</h2><p>ajax和jsonp这两种技术在调用方式上“看起来”很像目的也一样都是请求一个url然后把服务器返回的数据进行处理因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；<br>但ajax和jsonp其实本质上是不同的东西。</p>
<h2 id="ajax的核心"><a href="#ajax的核心" class="headerlink" title="ajax的核心"></a>ajax的核心</h2><p>ajax的核心是通过XmlHttpRequest获取非本页内容而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。<br>所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。<br> 还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！</p>
<h2 id="AJAX请求数据步骤是什么？传输的数据是用的get还是post？"><a href="#AJAX请求数据步骤是什么？传输的数据是用的get还是post？" class="headerlink" title="AJAX请求数据步骤是什么？传输的数据是用的get还是post？"></a>AJAX请求数据步骤是什么？传输的数据是用的get还是post？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var xhr;</div><div class="line">xhr = new XMLHttpRequest(); //创建一个异步对象</div><div class="line">xhr.open(&quot;Get&quot;, &quot;test.ashx&quot;, true);</div><div class="line">//Get 方式括号中的三个参数分别为：1.发送请求的方式 2.y 要请求的页面 3.是否异步</div><div class="line">//xhr.open(&quot;post&quot;，&quot;test.ashx&quot;，true)；</div><div class="line">//xhr.setRequestHeader(&quot;Content-Type&quot;，&quot;application/x-www-form-urlencoded&quot;)；Post方式发送数据</div><div class="line">//这个回调函数主要用来检测服务器是否把数据返回给异步对象</div><div class="line">xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;);//设置浏览器不使用缓存</div><div class="line">xhr.onreadystatechange = function () &#123;</div><div class="line">if (xhr.readystate == 4) &#123;</div><div class="line">//readyState 属性指出了 XMLHttpRequest 对象在发送/接收数据过程中所处的几个状态。</div><div class="line">//XMLHttpRequest 对象会经历 5 种不同的状态。</div><div class="line">//0、未初始化。对象已经创建，但还未初始化，即还没调用 open 方法；</div><div class="line">//1、已打开。对象已经创建并初始化，但还未调用 send 方法；</div><div class="line">//2、已发送。已经调用 send 方法，但该对象正在等待状态码和头的返回；</div><div class="line">//3、正在接收。已经接收了部分数据，但还不能使用该对象的属性和方法，因为状态和响应头不完整;</div><div class="line">//4、已加载。所有数据接收完毕</div><div class="line">if(xhr.status==200)&#123; //检测服务器返回的响应报文的状态码是否为 200</div><div class="line">alert(xhr.responseText);//服务器返回的 Response 数据,</div><div class="line">//解析服务器返回的 json 格式的数据</div><div class="line">var s=xhr.responseText;</div><div class="line">var json=eval(&quot;(&quot;+s+&quot;)&quot;);</div><div class="line">alert(jason.data);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">xhr.send(null);//异步对象发送请求</div><div class="line">//xhr.send(&quot;txtName=roger&amp;txtPwd=123&quot;);以 post 方式发送数据ajax中get和post方式请求数据都是明文的。</div></pre></td></tr></table></figure>
<h2 id="谈谈你对jquery的理解"><a href="#谈谈你对jquery的理解" class="headerlink" title="谈谈你对jquery的理解"></a>谈谈你对jquery的理解</h2><p>JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库，它兼容CSS3，还兼容各种浏览器（IE6.0+，FF1.5+，Safari2.0+，Opera9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需要定义id即可。jQuery是一个兼容多浏览器的javascript库，核心理念是writeless，domore(写得更少，做得更多)。</p>
<h2 id="关于jQuery的内部封装原理"><a href="#关于jQuery的内部封装原理" class="headerlink" title="关于jQuery的内部封装原理"></a>关于jQuery的内部封装原理</h2><p>1、为了防止全局变量污染，把jQuery的代码写在一个自调函数中，<br>2、咱们平常使用的$实际上jQuery对外暴漏的一个工厂函数，<br>3、而构造函数在jQuery的内部叫init，并且这个构造函数还被添加到了jQuery的原型中。当我们调用工厂函数的时候返回的其实是一个构造函数的实例<br>4、jQuery为了让第三方能够对其功能进行扩展，所以把工厂函数的原型与构造函数的原型保持了一致。这样只就外暴漏工厂函数，即可对原型进行扩展。</p>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>简单的说，作用域是针对变量的,比如我们创建一个函数fn1，函数里面又包了一个子函数fn2。此时就存在三个作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"> var a = 1;</div><div class="line"> function fn1() &#123;</div><div class="line">     var a = 1;</div><div class="line">     return function fn2() &#123;</div><div class="line">         var v = 3;</div><div class="line">         return a + v;</div><div class="line">     &#125;</div><div class="line">     return fn2;</div><div class="line"> &#125;</div><div class="line"> console.log(fn1); //输出的是一个fn1的函数体</div><div class="line"> console.log(fn1()); //输出的是fn2的函数体</div><div class="line"> console.log(fn1()()); //输出的是一个结果4</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>全局作用域、fn1作用域、fn2作用域；即全局作用域包含了fn1的作用域，fn2的作用域包含了fn1的作用域。</p>
<p>理解闭包首先要理解，js垃圾回收机制，也就是当一个函数被执行完后，其作用域会被收回，如果形成了闭包，执行完后其作用域就不会被收回。<br>如果某个函数被他的父函数之外的一个变量引用，就会形成闭包。当fn1在查找变量的时候会先从自身的作用域区查找，找不到再到上一级fn2的作用域查找，如果还没找到就到全局作用域区查找，这样就形成了一个作用域链。<br>闭包的作用，就是保存自己私有的变量，通过提供的接口（方法）给外部使用，但外部<br>不能直接访问该变量。</p>
<h2 id="JavaScript中的作用域、预解析与变量声明提升？"><a href="#JavaScript中的作用域、预解析与变量声明提升？" class="headerlink" title="JavaScript中的作用域、预解析与变量声明提升？"></a>JavaScript中的作用域、预解析与变量声明提升？</h2><h3 id="作用域：就是变量的有效范围。"><a href="#作用域：就是变量的有效范围。" class="headerlink" title="作用域：就是变量的有效范围。"></a>作用域：就是变量的有效范围。</h3><p>如何检测一个变量的作用域:在指定的区域内使用这个变量，如果不报错，说明这个变量的作用域包含此区域<br>函数作用域:只有函数能够划分变量的作用域，这种作用域的规则就叫函数作用域。如果在函数内访问一个变量，优先找局部变量和形参,如果没有找到，去定义该函数的环境中查找，直到全局为止。<br>在ES6之前，只有函数可以划分变量的作用域，所以在函数的外面无法访问函数内的变量。<br>在ES6之前，没有块级作用域的概念，所以在代码块的外面可以访问代码块内的变量<br>块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。</p>
<h2 id="块级作用域、函数作用域、词法作用域之间的区别："><a href="#块级作用域、函数作用域、词法作用域之间的区别：" class="headerlink" title="块级作用域、函数作用域、词法作用域之间的区别："></a>块级作用域、函数作用域、词法作用域之间的区别：</h2><p>1、块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域<br>2、词法作用域描述的是，变量的查找规则。</p>
<h2 id="之间的关系："><a href="#之间的关系：" class="headerlink" title="之间的关系："></a>之间的关系：</h2><p>（1）、块级作用域包含函数作用域<br>（2）、词法作用域与块级作用域、函数作用域之间没有任何交集，<br>他们从两个角度描述了作用域的规则。<br>ES6之前js采用的是函数作用域+词法作用域，ES6 js采用的是块级作用域+词法作用域。</p>
<h2 id="预解析："><a href="#预解析：" class="headerlink" title="预解析："></a>预解析：</h2><p>在代码整体执行之前，先解析一部分。<br>预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会重复执行。<br>js预解析干了什么事：js中预解析会把声明部分的代码预先执行。</p>
<h2 id="声明相关的代码可以分为两部分："><a href="#声明相关的代码可以分为两部分：" class="headerlink" title="声明相关的代码可以分为两部分："></a>声明相关的代码可以分为两部分：</h2><h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>通过var关键字定义的变量。</p>
<h3 id="2、函数声明"><a href="#2、函数声明" class="headerlink" title="2、函数声明"></a>2、函数声明</h3><p>通过function关键字声明的函数<br>预解析时如果遇到重复的变量声明，那么忽略。<br>预解析时如果遇到重复的函数声明，保留后面的函数。<br>预解析时如果遇到变量与函数重名的情况，保留函数。</p>
<h3 id="变量声明提升："><a href="#变量声明提升：" class="headerlink" title="变量声明提升："></a>变量声明提升：</h3><p>使用var关键字定义的变量，被称为变量声明；<br>函数声明提升的特点是，在函数声明的前面，可以调用这个函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Mrwang82.github.io/2017/10/17/this的理解/" data-id="cj8v2tg410002owtj44z996gg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="Mrwang82.github.io/2015/12/23/01浏览器兼容问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Web前端常见兼容问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2014/08/">八月 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="Mrwang82.github.io/2017/10/17/this的理解/">this的理解</a>
          </li>
        
          <li>
            <a href="Mrwang82.github.io/2015/12/23/01浏览器兼容问题/">Web前端常见兼容问题</a>
          </li>
        
          <li>
            <a href="Mrwang82.github.io/2014/08/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 小小王<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="Mrwang82.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="Mrwang82.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="Mrwang82.github.io/fancybox/jquery.fancybox.css">
  <script src="Mrwang82.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="Mrwang82.github.io/js/script.js"></script>

  </div>
</body>
</html>