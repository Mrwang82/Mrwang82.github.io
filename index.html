<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小小王</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="WEB前段、大前端、知识交流">
<meta property="og:type" content="website">
<meta property="og:title" content="小小王">
<meta property="og:url" content="https://Mrwang82.github.io/index.html">
<meta property="og:site_name" content="小小王">
<meta property="og:description" content="WEB前段、大前端、知识交流">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小小王">
<meta name="twitter:description" content="WEB前段、大前端、知识交流">
  
    <link rel="alternate" href="/atom.xml" title="小小王" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="Mrwang82.github.io/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="Mrwang82.github.io/" id="logo">小小王</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="Mrwang82.github.io/" id="subtitle">小小王的</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="Mrwang82.github.io/">Home</a>
        
          <a class="main-nav-link" href="Mrwang82.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Mrwang82.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-this的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="Mrwang82.github.io/2017/10/17/this的理解/" class="article-date">
  <time datetime="2017-10-17T01:22:20.013Z" itemprop="datePublished">2017-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="Mrwang82.github.io/2017/10/17/this的理解/">前端的一些知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Javascript内置的常用对象有哪些？并列举该对象常用的方法？（每种记忆三到五个）"><a href="#Javascript内置的常用对象有哪些？并列举该对象常用的方法？（每种记忆三到五个）" class="headerlink" title="Javascript内置的常用对象有哪些？并列举该对象常用的方法？（每种记忆三到五个）"></a>Javascript内置的常用对象有哪些？并列举该对象常用的方法？（每种记忆三到五个）</h2><h3 id="Arguments函数参数集合"><a href="#Arguments函数参数集合" class="headerlink" title="Arguments函数参数集合"></a>Arguments函数参数集合</h3><p>arguments[ ] 函数参数的数组<br>arguments一个函数的参数和其他属性<br>arguments.callee当前正在运行的函数<br>arguments.length传递给函数的参数的个数</p>
<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>toString()将数组转换成一个字符串<br>length属性动态获取数组长度<br>join()将一个数组转成字符串。返回一个字符串。<br>reverse()将数组中各元素颠倒顺序<br>delete运算符只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。<br>shift()删除数组中第一个元素，返回删除的那个值，并将长度减1。<br>unshift()往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a”，“b，“c”)<br>pop()删除数组中最后一个元素，返回删除的那个值，并将长度减1。<br>push()往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a”，“b”，“c”)<br>concat()连接数组<br>slice()返回数组的一部分<br>sort()对数组元素进行排序<br>splice()插入、删除或替换数组的元素<br>toLocaleString()把数组转换成局部字符串</p>
<h3 id="数组方法pop-、push-、unshift-、shift"><a href="#数组方法pop-、push-、unshift-、shift" class="headerlink" title="数组方法pop()、push()、unshift()、shift()"></a>数组方法pop()、push()、unshift()、shift()</h3><p>push() 尾部添加<br>pop() 删除并返回数组的最后一个元素<br>unshift() 头部添加<br>shift() 头部删除</p>
<h3 id="String字符串对象"><a href="#String字符串对象" class="headerlink" title="String字符串对象"></a>String字符串对象</h3><p>Length获取字符串的长度。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lenth = &apos;wqwqwqw&apos;;</div><div class="line">console.log(lenth.length);//7</div></pre></td></tr></table></figure></p>
<p>toLowerCase()将字符串中的字母转成全小写。如：strObj.toLowerCase()<br>split()将一个字符串转成数组。<br>charCodeAt()返回字符串中的第n个字符的代码<br>substr()在原始字符串，返回一个子字符串<br>substring()在原始字符串，返回一个子字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> var lenth = &apos;wqwqwqw&apos;;</div><div class="line">console.log(lenth.substring(2, 4)); //wq</div><div class="line">console.log(lenth.substr(2, 3)); //wqw</div></pre></td></tr></table></figure></p>
<p>concat()连接字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lenth = &apos;wqwqwqw&apos;;</div><div class="line">   console.log(lenth.concat(&apos;sasa&apos;));//wqwqwqwsasa</div></pre></td></tr></table></figure></p>
<p>indexOf()返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没有找到，则返回-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lenth = &apos;wqwqwqw&apos;;</div><div class="line">console.log(lenth.indexOf(&apos;e&apos;)); //-1</div></pre></td></tr></table></figure></p>
<p>lastIndexOf()从后向前检索一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lenth = &apos;wqwqwqw&apos;;</div><div class="line"> console.log(lenth.lastIndexOf(&apos;q&apos;)); //5</div></pre></td></tr></table></figure></p>
<p>replace()替换一个与正则表达式匹配的子串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lenth = &apos;wqwqwqw&apos;;</div><div class="line">console.log(lenth.replace(&apos;q&apos;, 123)); //w123wqwqw</div></pre></td></tr></table></figure></p>
<p>valueOf()返回字符串</p>
<h3 id="Boolean布尔对象"><a href="#Boolean布尔对象" class="headerlink" title="Boolean布尔对象"></a>Boolean布尔对象</h3><p>Boolean.toString()将布尔值转换成字符串<br>Boolean.valueOf()Boolean对象的布尔值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = new Boolean(0);</div><div class="line">console.log(num.valueOf()); //flase</div></pre></td></tr></table></figure></p>
<h3 id="Date日期时间"><a href="#Date日期时间" class="headerlink" title="Date日期时间"></a>Date日期时间</h3><p>创建Date对象的方法<br>1）创建当前(现在)日期对象的实例，不带任何参数var today=new Date()；<br>2）创建指定时间戳的日期对象实例，参数是时间戳。<br>时间戳：是指某一个时间距离1970年1月1日0时0分0秒，过去了多少毫秒值(1秒=1000毫秒)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var timer=new Date(10000);</div></pre></td></tr></table></figure></p>
<p>3）指定一个字符串的日期时间信息，参数是一个日期时间字符串<br> var timer = new Date(2017, 10, 11)</p>
<h3 id="Error异常对象"><a href="#Error异常对象" class="headerlink" title="Error异常对象"></a>Error异常对象</h3><p>Error.message可以读取的错误消息<br>Error.name错误的类型<br>TypeError当一个值的类型错误时，抛出该异常<br>URIError由URl的编码和解码方法抛出</p>
<h3 id="Function函数构造器"><a href="#Function函数构造器" class="headerlink" title="Function函数构造器"></a>Function函数构造器</h3><p>Function.apply()将函数作为一个对象的方法调用<br>Function.arguments[]传递给函数的参数<br>Function.call()将函数作为对象的方法调用<br>Function.length已声明的参数的个数<br>Function.prototype对象类的原型<br>Function.toString()把函数转换成字符串</p>
<h3 id="Math数学对象"><a href="#Math数学对象" class="headerlink" title="Math数学对象"></a>Math数学对象</h3><p>Math对象是一个静态对象<br>Math.PI圆周率。<br>Math.abs()绝对值。<br>Math.ceil()向上取整(整数加1，小数去掉)<br>Math.floor()向下取整(直接去掉小数)。</p>
<h3 id="Number数值对象"><a href="#Number数值对象" class="headerlink" title="Number数值对象"></a>Number数值对象</h3><p>Math.round()四舍五入。<br>Number.MAX_VALUE最大数值<br>Number.MIN_VALUE最小数值<br>Number.NaN特殊的非数字值<br>Number.toLocaleString()把数字转换成本地格式的字符串<br>Number.toString()将—个数字转换成字符串<br>Number.toPrecision()格式化数字的有效位<br>Number.valueOf()返回原始数值</p>
<h3 id="Object基础对象"><a href="#Object基础对象" class="headerlink" title="Object基础对象"></a>Object基础对象</h3><p>Object含有所有JavaScript对象的特性的超类<br>Object.constructor对象的构造函数<br>Object.hasOwnProperty()检查属性是否被继承<br>Object.isPrototypeOf()一个对象是否是另一个对象的原型<br>Object.toString()定义一个对象的字符串表示<br>Object.valueOf()指定对象的原始值</p>
<h3 id="RegExp正则表达式对象"><a href="#RegExp正则表达式对象" class="headerlink" title="RegExp正则表达式对象"></a>RegExp正则表达式对象</h3><p>RegExp.exec()通用的匹配模式<br>RegExp.global正则表达式是否全局匹配<br>RegExp.ignoreCase正则表达式是否区分大小写<br>RegExp.lastIndex下次匹配的起始位置<br>RegExp.source正则表达式的文本<br>RegExp.test()检测一个字符串是否匹配某个模式<br>RegExp.toString()把正则表达式转换成字符串</p>
<h2 id="JS的数据类型有哪些？"><a href="#JS的数据类型有哪些？" class="headerlink" title="JS的数据类型有哪些？"></a>JS的数据类型有哪些？</h2><p>简单数据类型：Undefined、Null、Boolean、Number和String。<br>复杂数据类型：Object Array<br>基本数据类型：Boolean、Number、String、Undefined、Null<br>基本数据类型中数字，字符串，布尔类型返回其对类型<br>undefined返回undefined<br>九大内置构造函数及其他所有函数返回function；<br>其他所有复杂类型对象和null返回object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alert(typeof [1, 2]); //object</div><div class="line">alert(typeof &apos;leipeng&apos;); //string</div><div class="line">var i = true;</div><div class="line">alert(typeof i); //boolean</div><div class="line">alert(typeof 1); //number</div><div class="line">var a;</div><div class="line">alert(typeof a); //undefined</div><div class="line">function a() &#123;;</div><div class="line">&#125;;</div><div class="line">alert(typeof a) //function</div></pre></td></tr></table></figure></p>
<h2 id="怎样判断一个JavaScript变量是array还是obiect？"><a href="#怎样判断一个JavaScript变量是array还是obiect？" class="headerlink" title="怎样判断一个JavaScript变量是array还是obiect？"></a>怎样判断一个JavaScript变量是array还是obiect？</h2><p>1、如果你只是用typeof来检查该变量，不论是array还是object，都将返回‘object’。此问题的一个可行的答案是检查该变量是不是object，并且检查该变量是否有数字长度（当为空array时长度也可能为0）。<br>然而，参数对象【argumentsobject】（传给制定函数的所有参数），也可能会适用于上述方法，技术上来说，参数对象并不是一个array。<br>此外，当一个对象有a.length属性的时候，这个方法也不成立。<br>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Real array 正在的数组</div><div class="line">var my_array = [];</div><div class="line">// Imposter! 冒名顶替的！</div><div class="line">var my_object = &#123;&#125;;</div><div class="line">my_object.length = 0; //当你调用length的时候会把它变成一个数组</div><div class="line">// Potentially faulty 潜在的错误</div><div class="line">function is_this_an_array(param) &#123;</div><div class="line">    if (typeof param === &apos;object&apos; &amp;&amp; !isNaN(param.length)) &#123;</div><div class="line">        console.log(&apos;Congrats, 你是一个数组!&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        console.log(&apos;Bummer, 你不是一个数组&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// Works 成功</div><div class="line">is_this_an_array(my_array);</div><div class="line">// Works, but is incorrect 成功了，但是不正确</div><div class="line">is_this_an_array(my_object);</div></pre></td></tr></table></figure></p>
<p>2、回答这个问题的另一个答案是用一个更加隐蔽的方法，调用toString()方法试着将该变量转化为代表其类型的string。<br>该方法对于真正的array可行；参数对象转化为string时返回[objectArguments]会转化失败；此外，对于含有数字长度属性的object类也会转化失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var my_array = [];</div><div class="line">  //Imposter!冒名顶替的！</div><div class="line">  var my_object = &#123;&#125;;</div><div class="line">  my_object.length = 0;</div><div class="line">  //Rocksolid坚如磐石（检验函数）</div><div class="line">  function is_this_an_array(param) &#123;</div><div class="line">      if (Object.prototype.toString.call(param) === &apos;[objectArray]&apos;) &#123;</div><div class="line">          console.log(&apos;Congrats,you have an array!&apos;);</div><div class="line">      &#125; else &#123;</div><div class="line">          console.log(&apos;Bummer,不是一个数组&apos;);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  is_this_an_array(my_array);</div><div class="line">  // // Works, but is incorrect 成功了，但是不正确</div><div class="line">  is_this_an_array(my_object);</div></pre></td></tr></table></figure></p>
<p>输出的不是一个数组<br>3、此外，可能在不可靠的多框架DOM环境中，instanceof是个完美合适的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var my_array = [];</div><div class="line"> if (my_array instanceof Array) &#123;</div><div class="line">     console.log(&apos;Congrats,你是一个数组!&apos;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>4、对于Javascript1.8.5（ECMAScript5），变量名字.isArray()可以实现这个目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var my_array = [];</div><div class="line"> if (Array.isArray(my_array)) &#123;</div><div class="line">     console.log(&apos;Congrats,你是一个数组!&apos;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="js的typeof返回哪些数据类型"><a href="#js的typeof返回哪些数据类型" class="headerlink" title="js的typeof返回哪些数据类型"></a>js的typeof返回哪些数据类型</h2><p>typeof一般判断基本数据类型。是一个操作符而不是函数，圆括号可有可无。<br>typeof返回值有：string，number，boolean，undefined，object，function，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = new Boolean();</div><div class="line">console.log(typeof num); //object</div></pre></td></tr></table></figure></p>
<h2 id="例举强制类型转换和隐式类型转换？"><a href="#例举强制类型转换和隐式类型转换？" class="headerlink" title="例举强制类型转换和隐式类型转换？"></a>例举强制类型转换和隐式类型转换？</h2><p>强制<br>转化成字符串toString()、String()<br>转换成数字Number()、parseInt()、parseFloat()<br>转换成布尔类型Boolean()<br>隐式<br>拼接字符串例子var str=””+18</p>
<ul>
<li>/  %  ===  ==<h3 id="split-、join-的区别"><a href="#split-、join-的区别" class="headerlink" title="split()、join()的区别"></a>split()、join()的区别</h3>Split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割<br>成数组的形式；<br>Split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割<br>成数组的形式；<h2 id="怎么判断一个变量是否null-undefined"><a href="#怎么判断一个变量是否null-undefined" class="headerlink" title="怎么判断一个变量是否null / undefined"></a>怎么判断一个变量是否null / undefined</h2><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined:"></a>Undefined:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (typeof(reValue) == &quot;undefined&quot;) &#123;</div><div class="line">        alert(&quot;undefined&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>typeof返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”Null:</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var exp = null;</div><div class="line">   if (!exp &amp;&amp; typeof(exp) != &quot;undefined&quot; &amp;&amp; exp != 0) &#123;</div><div class="line">       alert(&quot;isnull&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们在DOM应用中，一般只需要用(!exp)来判断就可以了，因为DOM应用中，可能返回null，可能返回undefined，如果具体判断null还是undefined会使程序过于复杂。</p>
<h2 id="“-”和”-”的不同"><a href="#“-”和”-”的不同" class="headerlink" title="“=”和”===”的不同"></a>“=”和”===”的不同</h2><p>“==”判断值是否相等，会自动转换类型；<br>“===”是判断值及类型是否完全相等，不会自动转换类型。</p>
<h2 id="面向对象和类的区别？"><a href="#面向对象和类的区别？" class="headerlink" title="面向对象和类的区别？"></a>面向对象和类的区别？</h2><h3 id="简单的说类是对象的模版"><a href="#简单的说类是对象的模版" class="headerlink" title="简单的说类是对象的模版"></a>简单的说类是对象的模版</h3><p>简单的说类是对象的模版</p>
<h3 id="面向对象有三大特性"><a href="#面向对象有三大特性" class="headerlink" title="面向对象有三大特性"></a>面向对象有三大特性</h3><p>1.抽象性，需要通过核心数据和特定环境才能描述对象的具体意义<br>2.封装性，封装就是将数据和功能组合到一起，在js中对象就是键值对的集合，对象将属性和方法封装起来，方法将过程封装起来<br>3.继承性，将别人的属性和方法成为自己的，传统继承基于模板(类)，js中继承基于构<br>造函数</p>
<h2 id="ECMAScript对象的继承结构"><a href="#ECMAScript对象的继承结构" class="headerlink" title="ECMAScript对象的继承结构"></a>ECMAScript对象的继承结构</h2><p>1.对象继承的终点是Object.prototype<br>2.所有函数默认的显示原型（即函数的prototype）都继承Object.prototype<br>3.谁的实例，这个实例就继承谁的prototype<br> 3.1所有的函数，都被看作是Function的实例，所以都继承Function.prototype<br> 3.2所有的数组，都被看作是Array的实例，所以都继承Array.prototype<br> 3.2所有的数组，都被看作是Array的实例，所以都继承Array.prototype<br>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>fn是Function的实例，所以继承Function.prototype<br>fn.prototype继承Object.prototype<br>new fn()是fn的实例,所以继承fn.prototype</p>
<h2 id="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。"><a href="#this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。" class="headerlink" title="this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。"></a>this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</h2><p>1.作为纯粹的函数调用this指向全局对象 ####<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function aleat() &#123;</div><div class="line">        // body...</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">    aleat(); //Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125;</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>2.作为对象的方法调用this指向调用对象 ####<br>3.作为构造函数被调用this指向新的对象（new会改变this的指向） ####<br>4.apply调用this指向apply方法的第一个参数 ####</p>
<h2 id="JS有哪些内置对象-。"><a href="#JS有哪些内置对象-。" class="headerlink" title="JS有哪些内置对象 #。"></a>JS有哪些内置对象 #。</h2><p>Object是JavaScript中所有对象的父对象 ####<br>其他对象：Function、Argument、Math、Date、RegExp、Error ####<br>数据封装类对象：Object、Array、Boolean、Number、String####<br>复杂(引用)类型：对象、数组、函数 ####</p>
<h2 id="表单验证传输的什么数据？明文还是暗文-加密？如何加密？是每一次传输数据，都是加密之后才传输吗？"><a href="#表单验证传输的什么数据？明文还是暗文-加密？如何加密？是每一次传输数据，都是加密之后才传输吗？" class="headerlink" title="表单验证传输的什么数据？明文还是暗文==加密？如何加密？是每一次传输数据，都是加密之后才传输吗？"></a>表单验证传输的什么数据？明文还是暗文==加密？如何加密？是每一次传输数据，都是加密之后才传输吗？</h2><p>GET是从服务器上请求数据，POST是发送数据到服务器。<br>GET方法是把数据参数队列（querystring）加到一个URL上，值和表单是一一对应的。比如说，name=John。在队列里，值和表单用一个&amp;符号分开，空格用+号替换，特殊的符号转换成十六进制的代码。<br>因为这一队列在URL里边，这样队列的参数就能看得到，可以被记录下来，或更改。通常GET方法还限制字符的大小（大概是256字节）。<br>事实上POST方法可以没有时间限制的传递数据到服务器，用户在浏览器端是看不到这一过程的，所以POST方法比较适合用于发送一个保密的（比如信用卡号）或者比较大量的数据到服务器。</p>
<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>Post是允许传输大量数据的方法，而Get方法会将所要传输的数据附在网址后面，然后一起送达服务器，因此传送的数据量就会受到限制，但是执行效率却比Post方法好。<br>get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；<br>所以，表达如果是向服务器传输数据(如帐号密码等)都是加密数据(post)，如果只是单单想要从服务器获得数据或者传输的数据并不重要，可以直接使用明文方式传输(get)</p>
<h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><p>对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题<br>1.下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header&#123;&quot;Access-Control-Allow-Origin: * &quot;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="请解释一下javascript的同源策略"><a href="#请解释一下javascript的同源策略" class="headerlink" title="请解释一下javascript的同源策略"></a>请解释一下javascript的同源策略</h2><h3 id="为什么会有同源策略？"><a href="#为什么会有同源策略？" class="headerlink" title="为什么会有同源策略？"></a>为什么会有同源策略？</h3><p>我们都知道JavaScript可以操作web文档的内容，试想，如果不对这一点加以限制，那么JS可以做的事情就太多了，危险性也太高，所以就针对它可以操作哪些文档的内容有了一个限制，这个限制就是同源策略。</p>
<h3 id="同源策略在什么情况下会起作用呢？"><a href="#同源策略在什么情况下会起作用呢？" class="headerlink" title="同源策略在什么情况下会起作用呢？"></a>同源策略在什么情况下会起作用呢？</h3><p>当web页面使用多个iframe元素或者打开其他浏览器窗口的时候，这一策略就会起作用。</p>
<h2 id="同源策略的含义："><a href="#同源策略的含义：" class="headerlink" title="同源策略的含义："></a>同源策略的含义：</h2><p>脚本只能读取和所属文档来源相同的窗口和文档的属性。这里就涉及到了一个浏览器如何判断两者是否同源以及如何判断脚本来源的问题。</p>
<p>###注意一点：脚本本身的来源并不作为判断是否同源的依据，而是将脚本所属文档的来源作为判断依据。</p>
<h2 id="1-判断脚本来源"><a href="#1-判断脚本来源" class="headerlink" title="1.判断脚本来源"></a>1.判断脚本来源</h2><p>例如：文档A中通过script的src引用了一个外部脚本，这个脚本是google提供的，也是从google的主机上加载到文档A中的，那么这个脚本的所属文档是谁呢，答案是文档A。</p>
<h2 id="2-判断是否同源"><a href="#2-判断是否同源" class="headerlink" title="2.判断是否同源"></a>2.判断是否同源</h2><p>理解了脚本来源，接着理解怎么判断是否同源：如果两个文档在协议、主机以及载入文档的URL端口这三点中有一点不同，就认为他们不同源。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p> 在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的<br>SONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function dosomething(jsondata)&#123;</div><div class="line">//处理获得的JSON数据</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>首先第一个script标签定义了一个处理数据的函数；然后第二个script标签载入一个js文件，http：//example.com/data.php是数据所在地址，但是因为是当做js来引入的，所以http：//example.com/data.php返回的必须是一个能执行的js文件；<br>最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php $callback = $_GET[&apos;callback&apos;]; //得到回调函数名</div><div class="line">$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //要返回的数据</div><div class="line">echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;; //输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理"></a>jsonp的原理</h2><p>jsonp的原理：动态创建script标签，回调函数### JSONP(JSONwithPadding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料而这种使用模式就是所谓的JSONP用JSONP抓到的资料并不是JSON而是任意的JavaScript用JavaScript直译器执行而不是用JSON解析器解析。</p>
<h2 id="jsonp为什么不是ajax"><a href="#jsonp为什么不是ajax" class="headerlink" title="jsonp为什么不是ajax"></a>jsonp为什么不是ajax</h2><p>ajax和jsonp这两种技术在调用方式上“看起来”很像目的也一样都是请求一个url然后把服务器返回的数据进行处理因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；<br>但ajax和jsonp其实本质上是不同的东西。</p>
<h2 id="ajax的核心"><a href="#ajax的核心" class="headerlink" title="ajax的核心"></a>ajax的核心</h2><p>ajax的核心是通过XmlHttpRequest获取非本页内容而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。<br>所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。<br> 还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！</p>
<h2 id="AJAX请求数据步骤是什么？传输的数据是用的get还是post？"><a href="#AJAX请求数据步骤是什么？传输的数据是用的get还是post？" class="headerlink" title="AJAX请求数据步骤是什么？传输的数据是用的get还是post？"></a>AJAX请求数据步骤是什么？传输的数据是用的get还是post？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var xhr;</div><div class="line">xhr = new XMLHttpRequest(); //创建一个异步对象</div><div class="line">xhr.open(&quot;Get&quot;, &quot;test.ashx&quot;, true);</div><div class="line">//Get 方式括号中的三个参数分别为：1.发送请求的方式 2.y 要请求的页面 3.是否异步</div><div class="line">//xhr.open(&quot;post&quot;，&quot;test.ashx&quot;，true)；</div><div class="line">//xhr.setRequestHeader(&quot;Content-Type&quot;，&quot;application/x-www-form-urlencoded&quot;)；Post方式发送数据</div><div class="line">//这个回调函数主要用来检测服务器是否把数据返回给异步对象</div><div class="line">xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;);//设置浏览器不使用缓存</div><div class="line">xhr.onreadystatechange = function () &#123;</div><div class="line">if (xhr.readystate == 4) &#123;</div><div class="line">//readyState 属性指出了 XMLHttpRequest 对象在发送/接收数据过程中所处的几个状态。</div><div class="line">//XMLHttpRequest 对象会经历 5 种不同的状态。</div><div class="line">//0、未初始化。对象已经创建，但还未初始化，即还没调用 open 方法；</div><div class="line">//1、已打开。对象已经创建并初始化，但还未调用 send 方法；</div><div class="line">//2、已发送。已经调用 send 方法，但该对象正在等待状态码和头的返回；</div><div class="line">//3、正在接收。已经接收了部分数据，但还不能使用该对象的属性和方法，因为状态和响应头不完整;</div><div class="line">//4、已加载。所有数据接收完毕</div><div class="line">if(xhr.status==200)&#123; //检测服务器返回的响应报文的状态码是否为 200</div><div class="line">alert(xhr.responseText);//服务器返回的 Response 数据,</div><div class="line">//解析服务器返回的 json 格式的数据</div><div class="line">var s=xhr.responseText;</div><div class="line">var json=eval(&quot;(&quot;+s+&quot;)&quot;);</div><div class="line">alert(jason.data);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">xhr.send(null);//异步对象发送请求</div><div class="line">//xhr.send(&quot;txtName=roger&amp;txtPwd=123&quot;);以 post 方式发送数据ajax中get和post方式请求数据都是明文的。</div></pre></td></tr></table></figure>
<h2 id="http超文本传输协议"><a href="#http超文本传输协议" class="headerlink" title="http超文本传输协议"></a>http超文本传输协议</h2><p>超文本传输协议（HTTP，HyperTextTransferProtocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件（即超文本文件（Hypertext），是指具有超链接功能的文件，它可以将文件中已经定义好的关键字（Keyword），经过鼠标的点取（Click），便可以得到该关键字的相关解释，这种方法使用户使用起来更感舒适。类似于早期使用的WIN32下的HELP文件。）都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>一次HTTP操作称为一个事务，其工作过程可分为四步：<br>1、首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。<br>2、建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、<br>协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3、服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本<br>号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4、客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务<br>器断开连接。<br>注意：如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示<br>屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h2 id="报文格式："><a href="#报文格式：" class="headerlink" title="报文格式："></a>报文格式：</h2><h3 id="请求报文格式如下："><a href="#请求报文格式如下：" class="headerlink" title="请求报文格式如下："></a>请求报文格式如下：</h3><p>请求行－通用信息头－请求头－实体头－报文主体</p>
<h3 id="应答报文格式如下："><a href="#应答报文格式如下：" class="headerlink" title="应答报文格式如下："></a>应答报文格式如下：</h3><p>状态行－通用信息头－响应头－实体头－报文主体</p>
<h3 id="协议功能："><a href="#协议功能：" class="headerlink" title="协议功能："></a>协议功能：</h3><p>HTTP协议（HyperTextTransferProtocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成<br>我们在浏览器的地址栏里输入的网站地址叫做URL(UniformResourceLocator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议是网络协议中最基本的协议之一，TCP（TransmissionControlProtocol传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立:"></a>连接建立:</h2><p>TCP是因特网中的传输层协议，使用三次握手协议建立连接，完成三次握手，客户端与服务器开始传送数据。</p>
<h2 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h2><h3 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h3><p>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，<br>等待服务器确认；SYN：同步序列编号（SynchronizeSequenceNumbers）。</p>
<h3 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h3><p>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<h3 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h3><p>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<h3 id="TCP协议的优缺点："><a href="#TCP协议的优缺点：" class="headerlink" title="TCP协议的优缺点："></a>TCP协议的优缺点：</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>TCP发送的包有序号，对方收到包后要给一个反馈，如果超过一定时间还没收到反馈就自动执行超时重发，因此TCP最大的优点是可靠。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>很简单，就是麻烦，如果数据量比较小的话建立连接的过程反而占了大头，不断地重发也会造成网络延迟，因此比如视频聊天通常就使用UDP，因为丢失一些包也没关系，速度流畅才是重要的。</p>
<h2 id="谈谈你对jquery的理解"><a href="#谈谈你对jquery的理解" class="headerlink" title="谈谈你对jquery的理解"></a>谈谈你对jquery的理解</h2><p>JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库，它兼容CSS3，还兼容各种浏览器（IE6.0+，FF1.5+，Safari2.0+，Opera9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需要定义id即可。jQuery是一个兼容多浏览器的javascript库，核心理念是writeless，domore(写得更少，做得更多)。</p>
<h2 id="关于jQuery的内部封装原理"><a href="#关于jQuery的内部封装原理" class="headerlink" title="关于jQuery的内部封装原理"></a>关于jQuery的内部封装原理</h2><p>1、为了防止全局变量污染，把jQuery的代码写在一个自调函数中，<br>2、咱们平常使用的$实际上jQuery对外暴漏的一个工厂函数，<br>3、而构造函数在jQuery的内部叫init，并且这个构造函数还被添加到了jQuery的原型中。当我们调用工厂函数的时候返回的其实是一个构造函数的实例<br>4、jQuery为了让第三方能够对其功能进行扩展，所以把工厂函数的原型与构造函数的原型保持了一致。这样只就外暴漏工厂函数，即可对原型进行扩展。</p>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>简单的说，作用域是针对变量的,比如我们创建一个函数fn1，函数里面又包了一个子函数fn2。此时就存在三个作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"> var a = 1;</div><div class="line"> function fn1() &#123;</div><div class="line">     var a = 1;</div><div class="line">     return function fn2() &#123;</div><div class="line">         var v = 3;</div><div class="line">         return a + v;</div><div class="line">     &#125;</div><div class="line">     return fn2;</div><div class="line"> &#125;</div><div class="line"> console.log(fn1); //输出的是一个fn1的函数体</div><div class="line"> console.log(fn1()); //输出的是fn2的函数体</div><div class="line"> console.log(fn1()()); //输出的是一个结果4</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>全局作用域、fn1作用域、fn2作用域；即全局作用域包含了fn1的作用域，fn2的作用域包含了fn1的作用域。</p>
<p>理解闭包首先要理解，js垃圾回收机制，也就是当一个函数被执行完后，其作用域会被收回，如果形成了闭包，执行完后其作用域就不会被收回。<br>如果某个函数被他的父函数之外的一个变量引用，就会形成闭包。当fn1在查找变量的时候会先从自身的作用域区查找，找不到再到上一级fn2的作用域查找，如果还没找到就到全局作用域区查找，这样就形成了一个作用域链。<br>闭包的作用，就是保存自己私有的变量，通过提供的接口（方法）给外部使用，但外部<br>不能直接访问该变量。</p>
<h2 id="JavaScript中的作用域、预解析与变量声明提升？"><a href="#JavaScript中的作用域、预解析与变量声明提升？" class="headerlink" title="JavaScript中的作用域、预解析与变量声明提升？"></a>JavaScript中的作用域、预解析与变量声明提升？</h2><h3 id="作用域：就是变量的有效范围。"><a href="#作用域：就是变量的有效范围。" class="headerlink" title="作用域：就是变量的有效范围。"></a>作用域：就是变量的有效范围。</h3><p>如何检测一个变量的作用域:在指定的区域内使用这个变量，如果不报错，说明这个变量的作用域包含此区域<br>函数作用域:只有函数能够划分变量的作用域，这种作用域的规则就叫函数作用域。如果在函数内访问一个变量，优先找局部变量和形参,如果没有找到，去定义该函数的环境中查找，直到全局为止。<br>在ES6之前，只有函数可以划分变量的作用域，所以在函数的外面无法访问函数内的变量。<br>在ES6之前，没有块级作用域的概念，所以在代码块的外面可以访问代码块内的变量<br>块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。</p>
<h2 id="块级作用域、函数作用域、词法作用域之间的区别："><a href="#块级作用域、函数作用域、词法作用域之间的区别：" class="headerlink" title="块级作用域、函数作用域、词法作用域之间的区别："></a>块级作用域、函数作用域、词法作用域之间的区别：</h2><p>1、块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域<br>2、词法作用域描述的是，变量的查找规则。</p>
<h2 id="之间的关系："><a href="#之间的关系：" class="headerlink" title="之间的关系："></a>之间的关系：</h2><p>（1）、块级作用域包含函数作用域<br>（2）、词法作用域与块级作用域、函数作用域之间没有任何交集，<br>他们从两个角度描述了作用域的规则。<br>ES6之前js采用的是函数作用域+词法作用域，ES6 js采用的是块级作用域+词法作用域。</p>
<h2 id="预解析："><a href="#预解析：" class="headerlink" title="预解析："></a>预解析：</h2><p>在代码整体执行之前，先解析一部分。<br>预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会重复执行。<br>js预解析干了什么事：js中预解析会把声明部分的代码预先执行。</p>
<h2 id="声明相关的代码可以分为两部分："><a href="#声明相关的代码可以分为两部分：" class="headerlink" title="声明相关的代码可以分为两部分："></a>声明相关的代码可以分为两部分：</h2><h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>通过var关键字定义的变量。</p>
<h3 id="2、函数声明"><a href="#2、函数声明" class="headerlink" title="2、函数声明"></a>2、函数声明</h3><p>通过function关键字声明的函数<br>预解析时如果遇到重复的变量声明，那么忽略。<br>预解析时如果遇到重复的函数声明，保留后面的函数。<br>预解析时如果遇到变量与函数重名的情况，保留函数。</p>
<h3 id="变量声明提升："><a href="#变量声明提升：" class="headerlink" title="变量声明提升："></a>变量声明提升：</h3><p>使用var关键字定义的变量，被称为变量声明；<br>函数声明提升的特点是，在函数声明的前面，可以调用这个函数。</p>
<h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>Javascript是面向对象的，每个实例对象都有一个_ <em>proto</em> <em>属性，该属性指向它原型对象，这个实例对象的构造函数有一个原型属性prototype，与实例的</em> <em>proto</em> <em>属性指向同一个对象。当一个对象在查找一个属性的时，自身没有就会根据</em> <em>proto</em> <em>向它的原型进行查找，如果都没有，则向它的原型的原型继续查找，直到查到Object.prototype.</em> <em>proto</em> _为null，这样也就形成了原型链。</p>
<h2 id="实现继承的方法有什么"><a href="#实现继承的方法有什么" class="headerlink" title="实现继承的方法有什么"></a>实现继承的方法有什么</h2><h3 id="（1）借用构造函数。也叫伪造对象或经典继承。"><a href="#（1）借用构造函数。也叫伪造对象或经典继承。" class="headerlink" title="（1）借用构造函数。也叫伪造对象或经典继承。"></a>（1）借用构造函数。也叫伪造对象或经典继承。</h3><p>思路：在子类构造函数的内部调用超类型构造函数。可以通过使用apply()和call()方法在新创建的对象上执行构造函数。<br>缺点：方法都在构造函数中定义，函数的复用就无从谈起。在超类型的原型中定义的方法，对子类而言也是不可见的，结果所有的类型都只能使用构造函数模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">//继承了SuperType</div><div class="line">SuperType.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors); // &quot;red,blue,green,black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors); // &quot;red,blue,green&quot;</div></pre></td></tr></table></figure></p>
<h3 id="（2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。"><a href="#（2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。" class="headerlink" title="（2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。"></a>（2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。</h3><p>思路：使用原型链实现对原型属性属性和方法的继承，通过借用构造函数来实现实例属性的继承。<br>优点：既通过在原型上定义方法实现了函数复用，又能保证每一个实例都有它自己的数组。<br>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为JavaScript中常用的继承模式。</p>
<h3 id="（3）原型链继承"><a href="#（3）原型链继承" class="headerlink" title="（3）原型链继承"></a>（3）原型链继承</h3><p>思路：借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。<br>在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line">function F()&#123;&#125;;</div><div class="line">F.prototype=o;</div><div class="line">return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="（4）寄生式继承"><a href="#（4）寄生式继承" class="headerlink" title="（4）寄生式继承"></a>（4）寄生式继承</h3><p>思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有的工作一样返回对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function createAonter(original)&#123;</div><div class="line">var clone = object(original);//通过调用函数创建一个新对象</div><div class="line">clone.sayHi=function()&#123;//以某种方式来增强这个对象</div><div class="line">alert(&quot;hi&quot;);</div><div class="line">&#125;</div><div class="line">return clone;//返回这个对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用二降低效率，这一点和构造函数模式类似。</p>
<h3 id="（5）寄生组合式继承。是JavaScript最常用的继承模式"><a href="#（5）寄生组合式继承。是JavaScript最常用的继承模式" class="headerlink" title="（5）寄生组合式继承。是JavaScript最常用的继承模式"></a>（5）寄生组合式继承。是JavaScript最常用的继承模式</h3><p>思路：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<br>开发人员普遍认为寄生组合式继承时引用类型最理想的继承范式。<br>extend（）方法才用了这样的方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Mrwang82.github.io/2017/10/17/this的理解/" data-id="cj8wnwlul0002lktj13dfm562" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-01浏览器兼容问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="Mrwang82.github.io/2015/12/23/01浏览器兼容问题/" class="article-date">
  <time datetime="2015-12-22T16:00:00.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="Mrwang82.github.io/2015/12/23/01浏览器兼容问题/">Web前端常见兼容问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>浏览器常见兼容问题<br>参考文献：<br> <a href="http://blog.csdn.net/chuyuqing/article/details/37561313/" target="_blank" rel="external">http://blog.csdn.net/chuyuqing/article/details/37561313/</a></p>
<h2 id="浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同"><a href="#浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同"></a>浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同</h2><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>
<p>碰到频率:100%</p>
<p>解决方案：CSS里    *{margin:0;padding:0;}  </p>
<p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>
<p>浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大</p>
<p>问题症状:常见症状是IE6中后面的一块被顶到下一行</p>
<p>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</p>
<p>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</p>
<p>备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。</p>
<p>浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</p>
<p>问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p>
<p>碰到频率：60%</p>
<p>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p>
<p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高</p>
<p>浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</p>
<p>问题症状：IE6里的间距比超过设置的间距</p>
<p>碰到几率：20%</p>
<p>解决方案：在display:block;后面加入display:inline;display:table;</p>
<p>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p>
<p>浏览器兼容问题五：图片默认有间距</p>
<p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p>
<p>碰到几率：20%</p>
<p>解决方案：使用float属性为img布局</p>
<p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</p>
<p>浏览器兼容问题六：标签最低高度设置min-height不兼容</p>
<p>问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p>
<p>碰到几率：5%</p>
<p>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</p>
<p>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p>
<h2 id="浏览器兼容问题七：透明度的兼容CSS设置"><a href="#浏览器兼容问题七：透明度的兼容CSS设置" class="headerlink" title="浏览器兼容问题七：透明度的兼容CSS设置"></a>浏览器兼容问题七：透明度的兼容CSS设置</h2><p>做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。</p>
<p>1./<em> CSS hack</em>/<br>我很少使用hacker的，可能是个人习惯吧，我不喜欢写的代码IE不兼容，然后用hack来解决。不过hacker还是非常好用的。使用hacker我可以把浏览器分为3类：IE6 ；IE7和遨游；其他（IE8 chrome ff safari opera等）<br>IE6认识的hacker 是下划线_ 和星号 <em><br>   IE7 遨游认识的hacker是星号 </em><br>   比如这样一个CSS设置：<br>   height:300px;<em>height:200px;_height:100px<br>    IE6浏览器在读到height:300px的时候会认为高时300px；继续往下读，他也认识</em>heihgt，  所以当IE6读到<em>height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。继续往下读，IE6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px；<br>  IE7和遨游也是一样的从高度300px的设置往下读。当它们读到</em>height200px的时候就停下了，因为它们不认识_height。所以它们会把高度解析为200px，剩下的浏览器只认识第一个height:300px;所以他们会把高度解析为300px。因为优先级相同且想冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。  </p>
<p>参考文献：<br><a href="http://blog.csdn.net/NtosKiking/article/details/52565502" target="_blank" rel="external">http://blog.csdn.net/NtosKiking/article/details/52565502</a><br>html的兼容性：<br>对于有的浏览器不支持HTML5的一些标签我们可以使用html5shiv.js来进行处理，html5shiv<br>内核是 IE Trident;FF 是 Gecko;opera 是 presto;safari and chrome 是 webkit</p>
<p>css的兼容性：</p>
<p>条件注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  &lt;!--[if IE 6]&gt;这里的内容只有IE6.0才能看见&lt;![endif]--&gt;</div><div class="line">&lt;!--[if gt IE 7]&gt;大于IE7&lt;![endif]&gt;</div></pre></td></tr></table></figure></p>
<p>Csshack：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">color:red;所有的浏览器都是可以识别的</div><div class="line"> _color:red;只有IE6可以识别 </div><div class="line">*color:red;+color:red;*+color:red;[color:red;IE6 7 识别</div><div class="line"> color:red\9 表示测试后发现IE678910都能识别</div><div class="line"> color:red\0 891011都能识别 </div><div class="line">color:!important表示最高的优先级，然后IE6不支持</div><div class="line"> 所以一般的顺序是 \9(678910)*(减少范围到67)_(只有6) </div><div class="line">&gt;2. css选择符级hack </div><div class="line">比如*html #demo&#123;color:red;&#125; 这是只有IE6才识别 </div><div class="line">：root #demo&#123;color:red\9&#125;只有IE9识别</div></pre></td></tr></table></figure></p>
<p>对于特定浏览器支持的样式我们有时要加-ms- -webkit- -moz- -o-进行兼容处理<br>注意的是IE10开始才支持animation<br>IE的透明效果<br>可以设置属性filter:alpha(opacity=0-100)<br>IE9开始支持透明度opacity<br>ff透明加 -moz-opacity:0.10;</p>
<p>常见的问题<br>IE的浮动margin变成双倍问题 解决添加display:inline;<br>添加clearfix 清除浮动</p>
<p>不同浏览器的对齐处理 使用margin:auto<br>使用reset.css兼容  百度搜索reset.css  重置css 的方法<br><a href="http://blog.csdn.net/NtosKiking/article/details/52565502" target="_blank" rel="external">http://blog.csdn.net/NtosKiking/article/details/52565502</a></p>
<p>外部的容器不需要定义高度，自适应<br>height:auto表示根据元素中的内容来确定高度，height:100%是继承父级元素的高度<br>!important 在IE6中不支持 在ff chrome 从IE7开始支持<br>!important 比内联元素的优先级高<br>\9（678910）不支持11</p>
<p>javascript的兼容性：</p>
<p>使用绑定事件的时候 addEventListener()</p>
<p>小于8的IE浏览器不支持event<br>要使用window.event 传递的参数是event<br>所以一般我们会写e = e||window.event; </p>
<p>我们获取scrollTop的时候<br>如果是指定对象的scrollTop的话 监听事件加在父元素上 以及获取值全都是在父元素的基础上</p>
<p>小于8的IE浏览器 不支持window.onclick 尽量都用document.onclick<br>实时监测input中输入的值<br>使用onchange[失去焦点的事件]要经过1.值变化2.onblur失去焦点事件，但是要引入jquery<br>而使用bind(“input”,function(){})能够实时监测 </p>
<p>input是常规的 propertychange是兼容IE的<br>使用js的话 就oninput onpropertychange<br>js中给定数值时要加单位px</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Mrwang82.github.io/2015/12/23/01浏览器兼容问题/" data-id="cj8wnwluc0000lktjzltggtci" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="Mrwang82.github.io/2014/08/12/hello-world/" class="article-date">
  <time datetime="2014-08-11T16:00:00.000Z" itemprop="datePublished">2014-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="Mrwang82.github.io/2014/08/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Mrwang82.github.io/2014/08/12/hello-world/" data-id="cj8wnwlui0001lktjbumf9kjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="Mrwang82.github.io/archives/2014/08/">八月 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="Mrwang82.github.io/2017/10/17/this的理解/">前端的一些知识</a>
          </li>
        
          <li>
            <a href="Mrwang82.github.io/2015/12/23/01浏览器兼容问题/">Web前端常见兼容问题</a>
          </li>
        
          <li>
            <a href="Mrwang82.github.io/2014/08/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 小小王<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="Mrwang82.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="Mrwang82.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="Mrwang82.github.io/fancybox/jquery.fancybox.css">
  <script src="Mrwang82.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="Mrwang82.github.io/js/script.js"></script>

  </div>
</body>
</html>